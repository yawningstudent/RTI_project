# RTI_project

Запуск: ./robot1 <route_filename>

1. Проект представляет собой реализацию взаимодействий между различными интерактивными объектами при совместном использовании пространства фабрики с помощью HLA (High — level architecture).

	HLA — это стандарт для систем моделирования, благодаря которому различные компоненты могут программироваться и запускаться независимо друг для друга. HLA включает следующие ключевые компоненты:

	1) RTI (run-time infrastructure) — программа, обеспечивающая взаимодействие между объектами симуляции и предоставляющая различные сервисы HLA: синхронизацию и т.д.

	2) Федерат — один из объектов симуляции, например, робот, визуализатор и т.д.

	3) Федерация — объединение всех взаимодействующих федератов, подключенных к RTI.

	4) Объектная модель федерации (FOM) — файл, содержащий описание классов федератов, взаимодействий и используемых типов данных (язык федерации).
	
	5) Исполнение федерации — сессия работы федерации.

2. Описание файлов:

	Проект на данный момент содержит следующие файлы:
	
		- Federate.cpp (класс)
		- Fedamb.cpp (класс)
		- Federate.h
		- Fedamb.h
		- robot#_main.cpp
		- fom.xml
		- Makefile
		- Файлы логов работы
		- input_route.txt

	1) Federate — это класс, который представляет собой реализацию робота как 
объекта, подключаемого к RTI, он содержит функции для односторонней связи с RTI (Federate → RTI), а также функции основной симуляции.

	2) Fedamb — это класс, который представляет собой реализацию робота как члена федерации. Условно, это класс, который предназначен для приёма сигналов от RTI.
	
	3) robot#_main.cpp — main каждого робота.

	4) fom.xml — это файл объектной модели федерации.

	5) Makefile — сборка одного робота, роботы отличаются именами, используемыми в коде.

	6) Файлы логов:

		- prog_logs — логи выполнения основной симуляции и обращений к RTI
		- callback_logs — логи полученных от RTI сигналов
		- movement_logs — логи пройденного роботом пути

	7) input_route.txt — файл с маршрутом, подаваемым на вход роботу

	Маршрут представляет собой набор точек такой, что до очередной точки можно добраться, изменяя только одну координату (ибо роботы, насколько я понимаю, передвигаются по размеченной сетке, и передвижение по диагонали нецелесообразно при координации большого числа движущихся объектов).

	Временно реализован следующим образом:

	В первой строке подаются стартовые координаты робота в формате Xs Ys.
Сначала подаётся буквенное обозначение первой подаваемой координаты, затем идёт список чередующихся абсцисс и ординат точек маршрута (вторая координата будет равна предыдущей поданной, так как движение идёт лишь по одной оси).

	*В данный момент поддерживает движение по двум точкам, как было оговорено в задании, но, в принципе, легко будет реализовать и произвольное число точек,так же подающееся в файле, ведь маршрутизатор должен полностью составить маршрут до старта робота.

3. К исправлению и доработке:
	1) Наладить одновременное изменение координат и получение данных от других объектов (На данный момент сначала происходит перемещение в новую точку и лишь затем получение данных) (возможно, использовать std::chrono)
	2) Нужна ли синхронизация перед отключением одного из объектов?
	3) А нужно ли вообще роботу направление движения? Кажется, нет...

4. Мысли о светлом будущем:
	1) Нужен ли командный модуль для старта и запуска сценария?
	2) Дописать функции для работы с взаимодействиями (interactions)
	3) Роботы могут отсылать следующие взаимодействия:
		- Принял груз
		- Доставил груз
		- Возникла исключительная ситуация
	4) Командный модуль может отсылать следующие взаимодействия:
		- Загрузка сценария
		- Загрузка завершилась успешно
		- Загрузка завершилась с ошибкой
		- Старт симуляции
		- Стоп симуляции
	5) Маршрутизатор может отсылать следующие взаимодействия:
		- Старт/стоп робота
		- Загрузка маршрута
		- Запрос состояния
		- Аварийное изменение маршрута (поломка одного из роботов → преграда)
		- и т.д. 
	6) Маршрут для очередного робота составляется маршрутизатором с учётом маршрутов всех остальных роботов, робот не может составлять маршрут сам и корректировать его по ситуации во время движения, так как это может привести к бесконечному пути до точки (написания алгоритма маршрутизации — моя работа?)
	7) Маршрут — ломаная, состоит из элементарных путей (отрезок, параллельный одной из координатных осей), соответственно, робот должен принимать список точек - вершин данной ломаной, написать функции для приёма такого списка и для движения по заданному маршруту
	8) Роботам функция обмена данными друг с другом не нужна, но пока что реализована с целью изучения и иллюстрации возможностей
